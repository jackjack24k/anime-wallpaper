"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NekosAPI = void 0;
const url_1 = require("url");
const base_1 = __importDefault(require("../base"));
const preventRateLimit_1 = require("./preventRateLimit");
const Tags_1 = require("./types/Tags");
class NekosAPI extends base_1.default {
    baseUrl;
    /*
    * Last time a request was sent to the API
    */
    static lastRequest = new Date();
    constructor(proxy) {
        super(proxy);
        this.baseUrl = "https://api.nekosapi.com/v3/";
        NekosAPI.lastRequest = new Date();
    }
    async getImage(tags, options) {
        const optionsWithLimit = Object.assign({ limit: 1 }, options);
        return (await this._getImages(tags, optionsWithLimit))[0];
    }
    async getImages(tags, options) {
        return (await this._getImages(tags, options));
    }
    async _getImages(tags, options) {
        const baseUrl = new url_1.URL(`${this.baseUrl}images?`);
        const url = this.processSearchParams(baseUrl, tags, options);
        return (await this.fetchResponse(url)).items;
    }
    async getRandomImage(tags, options) {
        const optionsWithLimit = Object.assign({ limit: 1 }, options);
        return (await this._getRandomImages(tags, optionsWithLimit))[0];
    }
    async _getRandomImages(tags, options) {
        const baseUrl = new url_1.URL(`${this.baseUrl}images/random?`);
        const url = this.processSearchParams(baseUrl, tags, options);
        return (await this.fetchResponse(url)).items;
    }
    async getImageByID(id) {
        const url = new url_1.URL(`${this.baseUrl}images/${id}`);
        return this.fetchResponse(url);
    }
    async getAllTags(options) {
        const baseUrl = new url_1.URL(`${this.baseUrl}images/tags`);
        const url = this.processSearchParams(baseUrl, [], options);
        return (await this.fetchResponse(url)).items;
    }
    async getTagByID(tagID) {
        return this._getTagByID(tagID);
    }
    async getTagByName(tagID) {
        return this._getTagByID(Tags_1.Tags[tagID]);
    }
    _getTagByID(tagID) {
        const url = new url_1.URL(`${this.baseUrl}images/tags/${tagID}`);
        return this.fetchResponse(url);
    }
    async getAllArtists(options) {
        const baseUrl = new url_1.URL(`${this.baseUrl}artists`);
        const url = this.processSearchParams(baseUrl, [], options);
        return (await this.fetchResponse(url)).items;
    }
    getArtistByID(artistID) {
        const url = new url_1.URL(`${this.baseUrl}artists/${artistID}`);
        return this.fetchResponse(url);
    }
    async getAllCharacters(options) {
        const baseUrl = new url_1.URL(`${this.baseUrl}characters`);
        const url = this.processSearchParams(baseUrl, [], options);
        return (await this.fetchResponse(url)).items;
    }
    getCharacterByID(characterID) {
        const url = new url_1.URL(`${this.baseUrl}characters/${characterID}`);
        return this.fetchResponse(url);
    }
    processSearchParams(url, tags, options) {
        const query = tags
            ? Array.isArray(tags)
                ? tags || []
                : [tags]
            : [];
        for (const tag of query) {
            url.searchParams.append("tag", String(Tags_1.Tags[tag]));
        }
        if (options) {
            for (const [key, value] of Object.entries(options)) {
                if (Array.isArray(value)) {
                    for (const arrayValue of value) {
                        url.searchParams.append(key, String(arrayValue));
                    }
                }
                else {
                    url.searchParams.append(key, String(value));
                }
            }
        }
        return url;
    }
}
exports.NekosAPI = NekosAPI;
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getImage", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getImages", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getRandomImage", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getImageByID", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getAllTags", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getTagByID", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getTagByName", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getAllArtists", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getArtistByID", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getAllCharacters", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getCharacterByID", null);
//# sourceMappingURL=NekosAPI.js.map