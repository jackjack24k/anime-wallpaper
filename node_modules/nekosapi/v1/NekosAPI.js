"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NekosAPI = void 0;
const url_1 = require("url");
const base_1 = __importDefault(require("../base"));
const NekosImage_1 = __importDefault(require("./NekosImage"));
const preventRateLimit_1 = require("./preventRateLimit");
class NekosAPI extends base_1.default {
    token;
    baseUrl;
    /*
    * Last time a request was sent to the API
    */
    static lastRequest = new Date();
    constructor(token, proxy) {
        super(proxy);
        if (token && NekosAPI.validateToken(token)) {
            this.token = token;
        }
        this.baseUrl = "https://v1.nekosapi.com/api/";
        NekosAPI.lastRequest = new Date();
    }
    async getImages(limit = 10, offset = 0) {
        if (!this.token)
            throw new Error("You need a valid access token to use this method.");
        const options = {
            method: "GET",
            headers: {
                "Authorization": `Bearer ${this.token}`,
            },
        };
        const url = new url_1.URL(`${this.baseUrl}image?`);
        url.searchParams.append("offset", String(offset));
        url.searchParams.append("limit", String(limit));
        const response = await this.fetchResponse(url, options);
        return response["data"]
            .map(image => new NekosImage_1.default(image));
    }
    async getRandomImages(categories, limit) {
        return this._getRandomImages(categories, limit);
    }
    async getRandomImage(categories) {
        return (await this._getRandomImages(categories, 1))[0];
    }
    async _getRandomImages(categories, limit) {
        const query = categories
            ? Array.isArray(categories)
                ? categories.join(",")
                : categories || ""
            : "";
        const limitQuery = limit || 1;
        const url = new url_1.URL(`${this.baseUrl}image/random?`);
        url.searchParams.append("categories", query);
        url.searchParams.append("limit", String(limitQuery));
        const response = await this.fetchResponse(url);
        return response["data"]
            .map(image => new NekosImage_1.default(image));
    }
    async getImageByID(id) {
        const url = new url_1.URL(`${this.baseUrl}image/${id}`);
        const response = await this.fetchResponse(url);
        return new NekosImage_1.default(response);
    }
    async getArtistByID(id) {
        const url = new url_1.URL(`${this.baseUrl}artist/${id}`);
        const response = await this.fetchResponse(url);
        return response["data"];
    }
    async getImagesByArtistID(id, limit = 10, offset = 0) {
        const url = new url_1.URL(`${this.baseUrl}artist/${id}/images?`);
        url.searchParams.append("limit", String(limit));
        url.searchParams.append("offset", String(offset));
        const response = await this.fetchResponse(url);
        return response["data"]
            .map(image => new NekosImage_1.default(image));
    }
    async getCharacterByID(id) {
        const url = new url_1.URL(`${this.baseUrl}character/${id}`);
        const response = await this.fetchResponse(url);
        return response["data"];
    }
    async getCategories(limit = 10, offset = 0) {
        const url = new url_1.URL(`${this.baseUrl}category?`);
        url.searchParams.append("limit", String(limit));
        url.searchParams.append("offset", String(offset));
        const response = await this.fetchResponse(url);
        return response["data"];
    }
    async getCategoryByID(categoryID) {
        const url = new url_1.URL(`${this.baseUrl}category/${categoryID}`);
        const response = await this.fetchResponse(url);
        return response["data"];
    }
    static validateToken(token) {
        if ((token && !token.match(NekosAPI.tokenRegex)?.length) || !token) {
            throw new Error("The token is invalid. It should be 100 characters long and contain numbers and lowercase/uppercase characters.");
        }
        else {
            return true;
        }
    }
    static tokenRegex = /^[0-9a-zA-Z]{100}$/g;
}
exports.NekosAPI = NekosAPI;
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getImages", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getRandomImages", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getRandomImage", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getImageByID", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getArtistByID", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getImagesByArtistID", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getCharacterByID", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getCategories", null);
__decorate([
    (0, preventRateLimit_1.preventRateLimit)()
], NekosAPI.prototype, "getCategoryByID", null);
//# sourceMappingURL=NekosAPI.js.map